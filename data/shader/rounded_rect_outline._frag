// https://thebookofshaders.com/edit.php

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

float ellipse_distance(vec2 uv, vec2 center, vec2 dims)
{
    return 1.-(pow((uv.x-center.x),2.0)/pow(dims.x,2.0) + pow((uv.y-center.y),2.0)/pow(dims.y,2.0));
}


float _fwidth(float p)
{
    return 0.01;
}

void main() {
    vec2 res = u_resolution;
    //res.y /= 2.;
    vec2 uv_varying = gl_FragCoord.xy/res.xy;
    vec3 stroke_color = vec3(0.080,0.277,0.745);
    float line_width = 63.784;
    vec2 line_width2 = line_width / res;
    
    vec2 nw = vec2(0.3);
    vec2 ne = vec2(0.3);
    vec2 se = vec2(0.3);
    vec2 sw = vec2(0.3);
    
    float dist = 0.0;
    float dist2 = 0.0;

    if(uv_varying.x < nw.x && uv_varying.y < nw.y)
    { 
      dist = ellipse_distance(uv_varying, nw, nw);
      float bias = _fwidth(dist);
      dist = smoothstep(0., 0. + bias, dist);
      if(line_width != 0.)
      {            
          dist2 = ellipse_distance(uv_varying, nw, nw-line_width2);
          bias = _fwidth(dist2);
          dist2 = smoothstep(0.+bias, 0., dist2);
          dist = min(dist, dist2);
      }
    }    
    else if (1.0 -  uv_varying.x < ne.x && uv_varying.y < ne.y)
    {
      dist = ellipse_distance(uv_varying, vec2(1.0-ne.x, ne.y), ne);
      float bias = _fwidth(dist);
      dist = smoothstep(0., 0. + bias, dist);
      if(line_width != 0.)
      { 
          dist2 = ellipse_distance(uv_varying, vec2(1.0-ne.x, ne.y), ne-line_width2);
          bias = _fwidth(dist2);
          dist2 = smoothstep(0.+bias, 0., dist2);
          dist = min(dist, dist2);
      }
    }
    else if (uv_varying.x < sw.x && 1.0 - uv_varying.y < sw.y)
    {
      dist = ellipse_distance(uv_varying, vec2(sw.x, 1.0-sw.y), sw);
      float bias = _fwidth(dist);
      dist = smoothstep(0., 0. + bias, dist);
      if(line_width != 0.)
      { 
          dist2 = ellipse_distance(uv_varying, vec2(sw.x, 1.0-sw.y), 
    sw-line_width2);
          bias = _fwidth(dist2);
          dist2 = smoothstep(0.+bias, 0., dist2);
          dist = min(dist, dist2);
      }
    }
    else if (1.0 -  uv_varying.x < se.x && 1.0 - uv_varying.y < se.y)
    {
      dist = ellipse_distance(uv_varying, vec2(1.0-se.x, 1.0-se.y), se);
      float bias = _fwidth(dist);
      dist = smoothstep(0., 0. + bias, dist);
      if(line_width != 0.)
      { 
          dist2 = ellipse_distance(uv_varying, vec2(1.0-se.x, 1.0-se.y), 
    se-line_width2);
          bias = _fwidth(dist2);
          dist2 = smoothstep(0.+bias, 0., dist2);
          dist = min(dist, dist2);
      }
    }
    else
    {
      if(line_width != 0.)
      {            
          if(uv_varying.x <= line_width2.x || uv_varying.y <= line_width2.y || uv_varying.x >= 1. - line_width2.x || uv_varying.y >= 1. - line_width2.y)
          {
              dist = 1.;
              stroke_color = vec3(0.745,0.446,0.248);
          }
      }
      else
      {
          dist = 1.;
      }
    }

    float alpha =  dist;

    gl_FragColor = vec4(stroke_color.rgb, alpha);
}